 # Введение в "Talk to Text": План обучения и разработки

 Добро пожаловать в твой первый бэкенд-проект! Этот документ — наша дорожная карта. Мы будем двигаться по ней шаг за шагом, создавая веб-сервис для транскрибации аудио и параллельно изучая ключевые технологии и концепции современной веб-разработки.

 ## Философия проекта

 1.  **Обучение в первую очередь**: Главная цель — не просто получить работающий продукт, а понять, как он устроен "под капотом".
 2.  **От простого к сложному**: Мы начнем с самого базового веб-сервера и постепенно будем добавлять функциональность: работу с файлами, базы данных, фоновые задачи и аутентификацию.
 3.  **Современный стек**: Мы будем использовать актуальные и востребованные инструменты, которые пригодятся тебе в будущей карьере.
 4.  **Итеративный подход**: Проект разбит на небольшие, логически завершенные этапы. После каждого этапа у тебя будет работающий кусочек приложения и новые знания.

 ## Технологический стек

 Вот что мы будем использовать:

 *   **Язык**: **TypeScript**. Так как ты пришел из мира Flutter (Dart), тебе будет комфортнее в типизированной среде. TypeScript — это стандарт де-факто для серьезной Node.js разработки, он помогает избегать множества ошибок.
 *   **Среда выполнения**: **Node.js**. Основа нашего бэкенда.
 *   **Веб-фреймворк**: **Express.js**. Это минималистичный и очень популярный фреймворк. Он идеально подходит для изучения основ: как работают запросы, ответы, middleware и роутинг.
 *   **База данных**: **PostgreSQL**. Мощная и надежная реляционная база данных.
 *   **ORM**: **Prisma**. Современный инструмент для работы с базой данных из TypeScript. Он обеспечивает строгую типизацию и упрощает написание запросов. Начнем мы, возможно, с **SQLite**, чтобы не тратить время на настройку, а потом легко переключимся на PostgreSQL.
 *   **Фоновые задачи (Очереди)**: **BullMQ** + **Redis**. Это необходимо для нашей архитектуры с задачами на обработку. Когда пользователь загружает файл, мы не заставляем его ждать, а создаем задачу, которая выполняется в фоновом режиме. Это ключ к масштабируемости.
 *   **Аутентификация**: **Passport.js**. Гибкая библиотека для аутентификации с поддержкой множества "стратегий" (Google, Apple, и т.д.).
 *   **Контейнеризация**: **Docker**. Позволит нам "упаковать" приложение и все его зависимости (базу данных, Redis) в контейнеры. Это гарантирует, что оно будет работать одинаково на твоей машине, на машине коллеги или на сервере.
 *   **Frontend**: **Solid.js**. Как ты и хотел, мы доберемся и до него, когда наш бэкенд будет готов.

 ## План разработки (Итерации)

 ### Фаза 1: Основы Node.js и Express

 *   **Шаг 1.1: "Hello, World!" на Express**.
     *   **Что делаем**: Инициализируем проект (`npm init`), устанавливаем TypeScript и Express. Создаем простейший сервер, который на GET-запрос по адресу `/` отвечает текстом "Hello, World!".
     *   **Что изучаем**: `npm`, `package.json`, основы TypeScript, компиляция `ts` в `js`, импорты/экспорты, основы Express (создание приложения, роутинг, request, response).

 *   **Шаг 1.2: Настройка проекта**.
     *   **Что делаем**: Настраиваем `tsconfig.json` для TypeScript. Добавляем `nodemon` для автоматического перезапуска сервера при изменениях кода. Структурируем проект: создаем папки для роутов, контроллеров.
     *   **Что изучаем**: Конфигурация TypeScript, удобные инструменты для разработки, базовая архитектура проекта.

 *   **Шаg 1.3: Прием файла**.
     *   **Что делаем**: Создаем `POST` эндпоинт `/upload`, который сможет принять аудиофайл от клиента. Пока просто сохраняем его во временную папку на сервере.
     *   **Что изучаем**: `POST` запросы, `multipart/form-data`, работа с файлами в Node.js (модуль `fs`), middleware на примере `multer`.

 ### Фаза 2: База данных и фоновые задачи

 *   **Шаг 2.1: Подключение Prisma и SQLite**.
     *   **Что делаем**: Устанавливаем Prisma. Описываем нашу первую модель данных (например, `AudioTask`). Создаем и применяем миграцию. При загрузке файла создаем запись в базе данных о новой задаче.
     *   **Что изучаем**: Основы ORM, схема данных Prisma, миграции, CRUD-операции (Create, Read, Update, Delete).

 *   **Шаг 2.2: Настройка Docker и PostgreSQL**.
     *   **Что делаем**: Пишем `docker-compose.yml` для запуска нашего приложения и базы данных PostgreSQL в контейнерах. Переключаем Prisma с SQLite на PostgreSQL.
     *   **Что изучаем**: Основы Docker и Docker Compose, переменные окружения (`.env`), подключение к БД в контейнере.

 *   **Шаг 2.3: Внедрение очереди задач (BullMQ)**.
     *   **Что делаем**: Добавляем в `docker-compose.yml` сервис Redis. Устанавливаем BullMQ. Вместо того чтобы просто сохранять файл, наш эндпоинт `/upload` теперь будет создавать задачу в очереди (например, `audio-processing-queue`) и передавать в нее путь к файлу.
     *   **Что изучаем**: Паттерн "Producer/Consumer", основы Redis, создание очередей и "воркеров" (обработчиков задач) с помощью BullMQ.

 ### Фаза 3: Реализация основной логики

 *   **Шаг 3.1: Воркер для нарезки аудио**.
     *   **Что делаем**: Создаем воркер, который слушает нашу очередь. Получив задачу, он использует библиотеку (например, `ffmpeg`) для проверки длительности аудио и, если нужно, нарезает его на части по 8 минут. Каждую часть он складывает в новую очередь (например, `transcription-queue`).
     *   **Что изучаем**: Работа с дочерними процессами в Node.js (`child_process`) для вызова консольных утилит, сложная логика в воркерах.

 *   **Шаг 3.2: Воркер для транскрибации**.
     *   **Что делаем**: Создаем второй воркер, который слушает `transcription-queue`. Он берет чанк аудио и отправляет его в сервис распознавания (для начала можно взять простое API, а позже подключить Whisper). Полученный текст сохраняем в базу данных, обновляя статус нашей задачи.
     *   **Что изучаем**: Работа с внешними API (`fetch`), асинхронность (`async/await`), обновление записей в БД.

 *   **Шаг 3.3: Получение результата**.
     *   **Что делаем**: Создаем `GET` эндпоинт `/tasks/:id/status`, который будет отдавать статус обработки задачи (в процессе, завершено, ошибка) и, если готово, сам распознанный текст.
     *   **Что изучаем**: Получение данных по ID, связь между таблицами в БД (если понадобится).

 ### Фаза 4: Аутентификация и Frontend

 *   **Шаг 4.1: Аутентификация через Google**.
     *   **Что делаем**: Добавляем в проект Passport.js и стратегию для Google. Создаем эндпоинты для начала аутентификации и callback. Защищаем наши эндпоинты (`/upload`, `/tasks/...`) так, чтобы они были доступны только авторизованным пользователям.
     *   **Что изучаем**: OAuth 2.0, сессии и/или JWT-токены, "защищенные" роуты.

 *   **Шаг 4.2: "Hello, World!" на Solid.js**.
     *   **Что делаем**: Создаем отдельную папку для фронтенда. Инициализируем проект на Solid.js. Создаем простую страницу с кнопкой "Войти через Google", которая будет вести на наш бэкенд-эндпоинт.
     *   **Что изучаем**: Основы Solid.js (компоненты, реактивность - сигналы), взаимодействие фронтенда и бэкенда.

 *   **Шаг 4.3: Полноценный интерфейс**.
     *   **Что делаем**: Создаем интерфейс для загрузки файла, отображения списка задач и их статусов.
     *   **Что изучаем**: Управление состоянием в Solid.js, условный рендеринг, работа с формами.
